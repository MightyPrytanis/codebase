import { PDFDocument, PDFCheckBox, PDFTextField, StandardFonts, degrees, rgb } from 'pdf-lib';
import { mapFormDataToFields, PresentationMode } from './form-mappings.js';

function toBase64(bytes: Uint8Array) {
  return Buffer.from(bytes).toString('base64');
}

function drawMultilineText(
  page: any,
  text: string,
  opts: { x: number; y: number; size: number; font: any; color: any; lineHeight?: number }
) {
  const lines = String(text).split(/\r?\n/);
  const lineHeight = opts.lineHeight ?? Math.ceil(opts.size * 1.15);
  let cursorY = opts.y;
  for (const line of lines) {
    page.drawText(line, { x: opts.x, y: cursorY, size: opts.size, font: opts.font, color: opts.color });
    cursorY -= lineHeight;
  }
}

export async function fillPdfForm(params: {
  templatePdf: Buffer;
  fieldMappings: Record<string, string>;
  formData: Record<string, unknown>;
}): Promise<{
  fieldsFilled: number;
  fieldsSkipped: number;
  skippedFields: string[];
  pdfBase64: string;
}> {
  const pdfDoc = await PDFDocument.load(params.templatePdf);
  const form = pdfDoc.getForm();
  const fields = form.getFields();
  const fieldMap = new Map<string, any>();
  fields.forEach((f) => fieldMap.set(f.getName(), f));

  const values = mapFormDataToFields(params.formData, params.fieldMappings);

  let fieldsFilled = 0;
  let fieldsSkipped = 0;
  const skippedFields: string[] = [];

  for (const [fieldName, rawValue] of values.entries()) {
    const direct = fieldMap.get(fieldName);

    // Special case: checkbox arrays like c1_3[0..4]
    if (!direct) {
      const baseName = String(fieldName).replace(/\[\d+\]$/, '');
      const candidates = Array.from(fieldMap.keys()).filter((n) => n.startsWith(`${baseName}[`));
      if (candidates.length > 0 && typeof rawValue === 'number' && Number.isInteger(rawValue)) {
        const targetName = candidates[rawValue];
        const targetField = targetName ? fieldMap.get(targetName) : undefined;
        if (targetField && targetField instanceof PDFCheckBox) {
          targetField.check();
          fieldsFilled++;
          continue;
        }
      }

      fieldsSkipped++;
      skippedFields.push(fieldName);
      continue;
    }

    if (direct instanceof PDFTextField) {
      direct.setText(String(rawValue));
      fieldsFilled++;
      continue;
    }

    if (direct instanceof PDFCheckBox) {
      const v = rawValue === true || rawValue === 'true' || rawValue === 1 || rawValue === '1' || rawValue === 'checked';
      if (v) direct.check();
      else direct.uncheck();
      fieldsFilled++;
      continue;
    }

    fieldsSkipped++;
    skippedFields.push(fieldName);
  }

  const bytes = await pdfDoc.save();
  return { fieldsFilled, fieldsSkipped, skippedFields: skippedFields.slice(0, 25), pdfBase64: toBase64(bytes) };
}

export async function applyBranding(params: {
  pdf: Buffer;
  presentationMode: PresentationMode;
}): Promise<{ pdfBase64: string }> {
  if (params.presentationMode === 'none') {
    return { pdfBase64: params.pdf.toString('base64') };
  }

  const pdfDoc = await PDFDocument.load(params.pdf);
  const pages = pdfDoc.getPages();
  const helvetica = await pdfDoc.embedFont(StandardFonts.Helvetica);
  const helveticaBold = await pdfDoc.embedFont(StandardFonts.HelveticaBold);

  const disclaimerText =
    'HYPOTHETICAL FORECAST - NOT FILING READY\n' +
    'This document is a hypothetical forecast generated by LexFiat Forecaster™.\n' +
    'It is not an official filing and is not filing-ready.\n' +
    'Consult a qualified tax professional before relying on this output.';

  for (const page of pages) {
    const { width, height } = page.getSize();
    if (params.presentationMode === 'strip') {
      page.drawRectangle({ x: 0, y: height - 40, width, height: 40, color: rgb(1, 0.8, 0) });
      page.drawText('LexFiat Forecaster™ - HYPOTHETICAL FORECAST - NOT FILING READY', {
        x: 10,
        y: height - 25,
        size: 10,
        font: helveticaBold,
        color: rgb(0, 0, 0)
      });
      drawMultilineText(page, disclaimerText, {
        x: 10,
        y: height - 34,
        size: 7,
        font: helvetica,
        color: rgb(0, 0, 0),
        lineHeight: 8
      });
    } else if (params.presentationMode === 'watermark') {
      page.drawText('LexFiat Forecaster™ - HYPOTHETICAL FORECAST', {
        x: width / 2 - 150,
        y: height / 2,
        size: 24,
        font: helveticaBold,
        color: rgb(0.8, 0.8, 0.8),
        rotate: degrees(-45),
        opacity: 0.3
      });
    }
  }

  const bytes = await pdfDoc.save();
  return { pdfBase64: toBase64(bytes) };

}
