import { PDFDocument, PDFCheckBox, PDFTextField, StandardFonts, degrees, rgb } from 'pdf-lib';
import { mapFormDataToFields, PresentationMode } from './form-mappings.js';

function toBase64(bytes: Uint8Array) {
  return Buffer.from(bytes).toString('base64');
}

function drawMultilineText(
  page: any,
  text: string,
  opts: { x: number; y: number; size: number; font: any; color: any; lineHeight?: number }
) {
  const lines = String(text).split(/\r?\n/);
  const lineHeight = opts.lineHeight ?? Math.ceil(opts.size * 1.15);
  let cursorY = opts.y;
  for (const line of lines) {
    page.drawText(line, { x: opts.x, y: cursorY, size: opts.size, font: opts.font, color: opts.color });
    cursorY -= lineHeight;
  }
}

export async function fillPdfForm(params: {
  templatePdf: Buffer;
  fieldMappings: Record<string, string>;
  formData: Record<string, unknown>;
}): Promise<{
  fieldsFilled: number;
  fieldsSkipped: number;
  skippedFields: string[];
  pdfBase64: string;
}> {
  const pdfDoc = await PDFDocument.load(params.templatePdf);
  const form = pdfDoc.getForm();
  const fields = form.getFields();
  const fieldMap = new Map<string, any>();
  fields.forEach((f) => fieldMap.set(f.getName(), f));

  const values = mapFormDataToFields(params.formData, params.fieldMappings);

  let fieldsFilled = 0;
  let fieldsSkipped = 0;
  const skippedFields: string[] = [];

  for (const [fieldName, rawValue] of values.entries()) {
    const field = fieldMap.get(fieldName);
    if (!field) {
      fieldsSkipped++;
      skippedFields.push(fieldName);
      continue;
    }
    if (field instanceof PDFTextField) {
      field.setText(String(rawValue));
      fieldsFilled++;
    } else if (field instanceof PDFCheckBox) {
      const v = rawValue === true || rawValue === 'true' || rawValue === 1 || rawValue === '1' || rawValue === 'checked';
      if (v) field.check();
      else field.uncheck();
      fieldsFilled++;
    } else {
      fieldsSkipped++;
      skippedFields.push(fieldName);
    }
  }

  const bytes = await pdfDoc.save();
  return { fieldsFilled, fieldsSkipped, skippedFields: skippedFields.slice(0, 25), pdfBase64: toBase64(bytes) };
}

export async function applyBranding(params: {
  pdf: Buffer;
  presentationMode: PresentationMode;
}): Promise<{ pdfBase64: string }> {
  if (params.presentationMode === 'none') {
    return { pdfBase64: params.pdf.toString('base64') };
  }

  const pdfDoc = await PDFDocument.load(params.pdf);
  const pages = pdfDoc.getPages();
  const helvetica = await pdfDoc.embedFont(StandardFonts.Helvetica);
  const helveticaBold = await pdfDoc.embedFont(StandardFonts.HelveticaBold);

  const disclaimerText =
    'HYPOTHETICAL FORECAST - NOT FILING READY\n' +
    'This document is a hypothetical forecast generated by LexFiat Forecaster™.\n' +
    'It is not an official filing and is not filing-ready.\n' +
    'Consult a qualified tax professional before relying on this output.';

  for (const page of pages) {
    const { width, height } = page.getSize();
    if (params.presentationMode === 'strip') {
      page.drawRectangle({ x: 0, y: height - 40, width, height: 40, color: rgb(1, 0.8, 0) });
      page.drawText('LexFiat Forecaster™ - HYPOTHETICAL FORECAST - NOT FILING READY', {
        x: 10,
        y: height - 25,
        size: 10,
        font: helveticaBold,
        color: rgb(0, 0, 0)
      });
      drawMultilineText(page, disclaimerText, {
        x: 10,
        y: height - 34,
        size: 7,
        font: helvetica,
        color: rgb(0, 0, 0),
        lineHeight: 8
      });
    } else if (params.presentationMode === 'watermark') {
      page.drawText('LexFiat Forecaster™ - HYPOTHETICAL FORECAST', {
        x: width / 2 - 150,
        y: height / 2,
        size: 24,
        font: helveticaBold,
        color: rgb(0.8, 0.8, 0.8),
        rotate: degrees(-45),
        opacity: 0.3
      });
    }
  }

  const bytes = await pdfDoc.save();
  return { pdfBase64: toBase64(bytes) };
}

